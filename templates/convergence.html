<!-- region COV BLOCK 1 -->
<!DOCTYPE html>
<html dir="rtl" lang="he">
<head>
    <meta charset="UTF-8">
    <title>×¡× ×›×¨×•×Ÿ ×¨×›×‘×•×ª ×•××•×˜×•×‘×•×¡×™×</title>
<!-- endregion COV BLOCK 1 -->


<!-- region COV BLOCK 2 -->
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 40px;
            direction: rtl;
            text-align: right;
        }

        svg text {
            cursor: default;
            user-select: none;
        }

        .train-item {
            cursor: pointer;
        }

        .layout-row {
            display: flex;
            gap: 28px;
            align-items: flex-start;
            width: 100%;
        }

        .viz-wrap {
            flex: 0 0 auto;
        }

        .table-wrap {
            flex: 1 1 auto;
            min-width: 520px;
            max-width: 980px;
            position: sticky;
            top: 8px;
            align-self: flex-start;
        }

        .table-wrap h3 {
            margin: 20px 0 8px 0;
            text-align: right;
        }

        .table-actions {
            display: flex;
            align-items: center;
            gap: 12px;
            margin: 8px 0 10px 0;
        }

        #clearBusSelectionBtn {
            padding: 6px 10px;
            cursor: pointer;
            border: 1px solid #999;
            background: #fff;
            border-radius: 6px;
        }

        #selectionHint {
            font-size: 12px;
            color: #333;
        }

        .table-scroll {
            max-height: 900px;
            overflow-y: auto;
            overflow-x: hidden;
            border: 1px solid #bbb;
            border-radius: 8px;
            direction: ltr;
            padding-right: 8px;
            box-sizing: border-box;
            scrollbar-gutter: stable;
        }

        .table-scroll-top {
            overflow-x: auto;
            overflow-y: hidden;
            border: 1px solid #bbb;
            border-bottom: 0;
            border-radius: 8px 8px 0 0;
            height: 16px;
            direction: ltr;
        }

        #busTableTopScrollInner {
            height: 1px;
        }

        #busTable {
            width: 100%;
            border-collapse: collapse;
            direction: rtl;
        }

        #busTable th, #busTable td {
            border-bottom: 1px solid #ddd;
            padding: 8px 10px;
            font-size: 12px;
            text-align: right;
            white-space: nowrap;
        }

        /* In RTL table, first DOM column is visually rightmost ("××¤×¢×™×œ"). */
        #busTable th:first-child,
        #busTable td:first-child {
            padding-right: 22px;
        }

        #busTable th {
            position: sticky;
            top: 0;
            background: #f3f3f3;
            z-index: 2;
            font-weight: 700;
        }

        #busTable tbody tr:nth-child(even) {
            background: #fafafa;
        }

        #busTable tbody tr:hover {
            background: #eef6ff;
        }

        .th-wrap {
            position: relative;
            padding-right: 22px;
        }

        .th-search-btn {
            position: absolute;
            right: 6px;
            bottom: 4px;
            cursor: pointer;
            font-size: 14px;
            user-select: none;
            opacity: 0.85;
        }

        .th-search-btn:hover {
            opacity: 1;
        }

        .hdr-popup {
            position: absolute;
            z-index: 9999;
            width: 220px;
            background: #fff;
            border: 1px solid #bbb;
            border-radius: 10px;
            box-shadow: 0 10px 24px rgba(0,0,0,0.15);
            padding: 10px;
            display: none;
        }

        .hdr-popup .popup-title {
            font-weight: 700;
            margin-bottom: 8px;
        }

        .hdr-popup .popup-title-selected {
            font-weight: 400;
        }

        .hdr-popup input {
            width: 100%;
            padding: 6px 8px;
            border-radius: 8px;
            border: 1px solid #ccc;
            margin-bottom: 8px;
            box-sizing: border-box;
        }

        .hdr-popup .popup-list {
            max-height: 180px;
            overflow: auto;
            border-top: 1px solid #eee;
            padding-top: 6px;
        }

        .hdr-popup .popup-item {
            padding: 6px 8px;
            border-radius: 8px;
            cursor: pointer;
            text-align: right;
        }

        .hdr-popup .popup-item:hover {
            background: #f2f2f2;
        }

        .hdr-popup .popup-actions {
            display: flex;
            gap: 8px;
            margin-top: 8px;
            justify-content: flex-end;
        }

        .hdr-popup .btn {
            border: 1px solid #999;
            background: #fff;
            border-radius: 8px;
            padding: 4px 10px;
            cursor: pointer;
        }

    </style>
</head>
<!-- endregion COV BLOCK 2 -->


<!-- region COV BLOCK 3 -->
<body>

<h2 id="stationTitle"></h2>
<!-- endregion COV BLOCK 3 -->


<!-- region COV BLOCK 4 -->
<div class="layout-row">

    <div class="viz-wrap" style="display:flex; justify-content:center;">

        <svg id="arrowSVG" width="240" height="1960" style="margin-top:20px;">

          <line x1="112" y1="30" x2="112" y2="1920" stroke="#3f3f3f" stroke-width="3"/>
          <line x1="128" y1="30" x2="128" y2="1920" stroke="#3f3f3f" stroke-width="3"/>

          <text x="100" y="40"  font-size="12">05:00</text>
          <text x="100" y="197" font-size="12">07:00</text>
          <text x="100" y="354" font-size="12">09:00</text>
          <text x="100" y="511" font-size="12">11:00</text>
          <text x="100" y="668" font-size="12">13:00</text>
          <text x="100" y="825" font-size="12">15:00</text>
          <text x="100" y="982" font-size="12">17:00</text>
          <text x="100" y="1139" font-size="12">19:00</text>
          <text x="100" y="1296" font-size="12">21:00</text>
          <text x="100" y="1453" font-size="12">23:00</text>
          <text x="100" y="1610" font-size="12">01:00</text>
          <text x="100" y="1767" font-size="12">03:00</text>
          <text x="100" y="1924" font-size="12">05:00</text>

        </svg>

    </div>

    <div class="table-wrap">

        <h3 id="tableTitle">×˜×‘×œ×ª × ×¡×™×¢×•×ª</h3>

        <div class="table-actions">
            <button id="clearBusSelectionBtn" type="button">×”×¦×’ ×”×›×œ</button>
        </div>

        <div id="busTableTopScroll" class="table-scroll-top">
            <div id="busTableTopScrollInner"></div>
        </div>
        <div id="busTableMainScroll" class="table-scroll">
            <table id="busTable">
                <thead>
                    <tr id="busTableHeaderRow"></tr>
                </thead>
                <tbody id="busTableBody"></tbody>
            </table>
        </div>

    </div>

</div>
<!-- endregion COV BLOCK 4 -->


<script>
// region COV 5A
function extractHHMM(timeValue) {
    if (timeValue === null || timeValue === undefined) return null;

    let s = String(timeValue).trim();
    if (!s) return null;

    if (s.includes("T")) s = s.split("T").pop();
    if (s.includes(" ")) s = s.split(" ").pop();
    if (s.includes("+")) s = s.split("+")[0];
    if (s.includes(".")) s = s.split(".")[0];

    const match = s.match(/(\d{1,2}):(\d{2})(?::(\d{2}))?/);
    if (!match) return null;

    const hh = parseInt(match[1], 10);
    const mm = parseInt(match[2], 10);
    if (Number.isNaN(hh) || Number.isNaN(mm)) return null;

    const hh2 = ((hh % 24) + 24) % 24;
    return String(hh2).padStart(2, "0") + ":" + String(mm).padStart(2, "0");
}
// endregion COV 5A


// region COV 5B
function timeToY(timeValue) {
    const hhmm = extractHHMM(timeValue);
    if (!hhmm) return null;

    const parts = hhmm.split(":").map(Number);
    if (parts.length < 2 || Number.isNaN(parts[0]) || Number.isNaN(parts[1])) return null;

    const h = parts[0];
    const m = parts[1];

    let minutes = h * 60 + m;
    const anchor = 5 * 60;

    if (minutes < anchor) {
        minutes += 24 * 60;
    }

    const relative = minutes - anchor;

    const topY = 40;
    const bottomY = 1920;
    const fraction = relative / (24 * 60);

    return topY + fraction * (bottomY - topY);
}
// endregion COV 5B


// region COV 5C
const BUS_TO_RAIL_JSON = {{ bus_to_rail_df_js|safe }};
const RAIL_TO_BUS_JSON = {{ rail_to_bus_df_js|safe }};
const TRAIN_PERC = {{ train_perc_js|safe }};
const YEAR_MONTH_PAIRS = {{ year_month_pairs_js|safe }};

const params = new URLSearchParams(window.location.search);
const station = params.get("station");

const yearStr = params.get("year");
const monthStr = params.get("month");

const selectedYear  = yearStr  ? parseInt(yearStr, 10)  : null;
const selectedMonth = monthStr ? parseInt(monthStr, 10) : null;

let activeYear  = Number.isFinite(selectedYear)  ? selectedYear  : null;
let activeMonth = Number.isFinite(selectedMonth) ? selectedMonth : null;

function toIntAny(v) {
    const n = parseInt(String(v ?? "").trim(), 10);
    return Number.isFinite(n) ? n : null;
}

function buildPercKeyForLookup(row, trainId) {
    const y = Number.isFinite(activeYear) ? activeYear : toIntAny(row["×©× ×”"]);
    const m = Number.isFinite(activeMonth) ? activeMonth : toIntAny(row["×—×•×“×©"]);
    const dir = String(row["×›×™×•×•×Ÿ × ×¡×™×¢×ª ×”×¨×›×‘×ª"] ?? "").trim().replace(/\s+/g, " ");

    if (y === null || m === null || !trainId || !dir) return null;
    return String(y) + "_" + String(m) + "_" + String(trainId).trim() + "_" + dir;
}

function updateTitleFromState() {
    const titleEl = document.getElementById("stationTitle");
    if (!titleEl) return;

    const hasYM = Number.isFinite(activeYear) && Number.isFinite(activeMonth);
    const ymTxt = hasYM ? (" | " + activeYear + "-" + String(activeMonth).padStart(2, "0")) : "";

    titleEl.innerText = station
        ? ("×¡× ×›×¨×•×Ÿ: " + station + ymTxt)
        : ("×¡× ×›×¨×•×Ÿ" + ymTxt);
}
// endregion COV 5C


// region COV 5D
let activeDirection = "×œ×›×™×•×•×Ÿ ×ª×œ ××‘×™×‘";
let activeTrain = null;
let activeTrainUid = null;
let activeBusRowKey = null;

function getMasterData() {
    return (activeDirection === "×œ×›×™×•×•×Ÿ ×ª×œ ××‘×™×‘") ? BUS_TO_RAIL_JSON : RAIL_TO_BUS_JSON;
}

let stationTimes = [];

function rebuildStationTimes() {
    const data = getMasterData();

    stationTimes = data.filter(t => {
        const st = String(t["×©× ×ª×—× ×ª ×”×¨×›×‘×ª"] ?? "").trim();
        if (!station || st !== station) return false;

        if (Number.isFinite(activeYear)) {
            const y = toIntAny(t["×©× ×”"]);
            if (y !== null && y !== activeYear) return false;
        }
        if (Number.isFinite(activeMonth)) {
            const m = toIntAny(t["×—×•×“×©"]);
            if (m !== null && m !== activeMonth) return false;
        }

        return true;
    });
}

const svg = document.getElementById("arrowSVG");
// endregion COV 5D


// region COV 5E
function applyBusFilter() {
    const buses = svg.querySelectorAll(".bus-item");
    buses.forEach(b => {
        const tid = b.getAttribute("data-train") || "";
        b.style.display = (!activeTrain || tid === activeTrain) ? "" : "none";
    });
}

function clearTrainOutlines() {
    const trains = svg.querySelectorAll(".train-item");
    trains.forEach(t => {
        t.setAttribute("stroke", "none");
        t.setAttribute("stroke-width", "0");
    });
}

function applyPercFilter() {
    const percs = svg.querySelectorAll(".perc-item");
    percs.forEach(p => {
        const uid = p.getAttribute("data-train-uid") || "";
        const tid = p.getAttribute("data-train") || "";
        if (!activeTrain) {
            p.style.display = "none";
            return;
        }
        p.style.display = (activeTrainUid ? (uid === activeTrainUid) : (tid === activeTrain)) ? "" : "none";
    });
}

function setActiveTrain(trainId, trainUid = null) {
    activeTrain = trainId ? String(trainId) : null;
    activeTrainUid = trainUid ? String(trainUid) : null;

    applyBusFilter();
    applyPercFilter();

    clearTrainOutlines();
    if (activeTrain) {
        const selector = activeTrainUid
            ? '.train-item[data-train-uid="' + activeTrainUid + '"]'
            : '.train-item[data-train="' + activeTrain + '"]';
        const selected = svg.querySelectorAll(selector);
        selected.forEach(t => {
            t.setAttribute("stroke", "#cc0000");
            t.setAttribute("stroke-width", "1.5");
        });
    }

    if (typeof renderBusTable === "function") {
        renderBusTable();
    }
}
// endregion COV 5E


// region COV 5F
const resetBtn = document.createElement("button");
resetBtn.textContent = "××™×¤×•×¡ ×¡×™× ×•×Ÿ ×¨×›×‘×•×ª";
resetBtn.style.cssText =
    "margin: 40px 0 0 0; padding: 6px 10px; cursor:pointer; border:1px solid #999; background:#fff; border-radius:6px;";

const h2 = document.querySelector("h2");
if (h2 && h2.parentNode) {
    h2.parentNode.insertBefore(resetBtn, h2.nextSibling);
}

resetBtn.addEventListener("click", () => {
    setActiveTrain(null);
});

const dirSelect = document.createElement("select");
dirSelect.innerHTML = `
    <option value="×œ×›×™×•×•×Ÿ ×ª×œ ××‘×™×‘">×œ×›×™×•×•×Ÿ ×ª×œ ××‘×™×‘</option>
    <option value="××›×™×•×•×Ÿ ×ª×œ ××‘×™×‘">××›×™×•×•×Ÿ ×ª×œ ××‘×™×‘</option>`;
dirSelect.style.cssText =
    "margin:10px 10px; padding:4px; border-radius:6px; cursor:pointer;";
resetBtn.parentNode.insertBefore(dirSelect, resetBtn.nextSibling);

const yearSelect = document.createElement("select");
yearSelect.style.cssText =
    "margin:10px 10px; padding:4px; border-radius:6px; cursor:pointer;";

const monthSelect = document.createElement("select");
monthSelect.style.cssText =
    "margin:10px 10px; padding:4px; border-radius:6px; cursor:pointer;";

resetBtn.parentNode.insertBefore(yearSelect, dirSelect.nextSibling);
resetBtn.parentNode.insertBefore(monthSelect, yearSelect.nextSibling);

let activeOperator = "";
const COL_OPERATOR = "\u05de\u05e4\u05e2\u05d9\u05dc";
const COL_WEEK = "\u05ea\u05e7\u05d5\u05e4\u05ea \u05e9\u05d1\u05d5\u05e2";

let activeWeek = "×™×•× ×—×•×œ";

const weekSelect = document.createElement("select");
weekSelect.style.cssText =
    "margin:10px 10px; padding:4px; border-radius:6px; cursor:pointer;";

resetBtn.parentNode.insertBefore(weekSelect, monthSelect.nextSibling);

const operatorSelect = document.createElement("select");
operatorSelect.style.cssText =
    "margin:10px 10px; padding:4px; border-radius:6px; cursor:pointer;";

resetBtn.parentNode.insertBefore(operatorSelect, weekSelect.nextSibling);

dirSelect.value = activeDirection;
// endregion COV 5F


// region COV 5G
function getYearMonthPairsForStation() {
    return (YEAR_MONTH_PAIRS || [])
        .map(p => ({ y: parseInt(p.year, 10), m: parseInt(p.month, 10) }))
        .filter(p => Number.isFinite(p.y) && Number.isFinite(p.m));
}

function populateYearDropdown() {
    const pairs = getYearMonthPairsForStation();
    const years = Array.from(new Set(pairs.map(p => p.y))).sort((a, b) => a - b);

    yearSelect.innerHTML = "";
    years.forEach(y => {
        const opt = document.createElement("option");
        opt.value = String(y);
        opt.textContent = String(y);
        yearSelect.appendChild(opt);
    });

    if (Number.isFinite(activeYear) && years.includes(activeYear)) {
        yearSelect.value = String(activeYear);
    } else if (Number.isFinite(selectedYear) && years.includes(selectedYear)) {
        yearSelect.value = String(selectedYear);
        activeYear = selectedYear;
    } else if (years.length) {
        yearSelect.value = String(years[0]);
        activeYear = years[0];
    } else {
        activeYear = null;
    }
}

function populateMonthDropdown() {
    const ySel = parseInt(yearSelect.value, 10);
    const pairs = getYearMonthPairsForStation();

    const months = Array.from(new Set(
        pairs.filter(p => p.y === ySel).map(p => p.m)
    )).sort((a, b) => a - b);

    monthSelect.innerHTML = "";
    months.forEach(m => {
        const opt = document.createElement("option");
        opt.value = String(m);
        opt.textContent = String(m).padStart(2, "0");
        monthSelect.appendChild(opt);
    });

    if (Number.isFinite(activeMonth) && months.includes(activeMonth)) {
        monthSelect.value = String(activeMonth);
    } else if (
        Number.isFinite(selectedMonth) &&
        months.includes(selectedMonth) &&
        String(ySel) === String(selectedYear)
    ) {
        monthSelect.value = String(selectedMonth);
        activeMonth = selectedMonth;
    } else if (months.length) {
        monthSelect.value = String(months[0]);
        activeMonth = months[0];
    } else {
        activeMonth = null;
    }
}
// endregion COV 5G


// region COV 5H
function populateWeekDropdown() {
    weekSelect.innerHTML = "";

    const set = new Set();
    stationTimes.forEach(r => {
        const v = String(r["×ª×§×•×¤×ª ×©×‘×•×¢"] ?? "").trim();
        if (v) set.add(v);
    });

    const weeks = Array.from(set).sort();

    weeks.forEach(v => {
        const opt = document.createElement("option");
        opt.value = v;
        opt.textContent = v;
        weekSelect.appendChild(opt);
    });

    if (weeks.includes("×™×•× ×—×•×œ")) {
        activeWeek = "×™×•× ×—×•×œ";
    } else if (weeks.length) {
        activeWeek = weeks[0];
    }

    weekSelect.value = activeWeek;
}

function populateOperatorDropdown() {
    operatorSelect.innerHTML = "";
    const allOpt = document.createElement("option");
    allOpt.value = "";
    allOpt.textContent = COL_OPERATOR;
    operatorSelect.appendChild(allOpt);
    const set = new Set();
    stationTimes
        .filter(r => String(r[COL_WEEK] ?? "").trim() === activeWeek)
        .forEach(r => {
            const v = String(r[COL_OPERATOR] ?? "").trim();
            if (v) set.add(v);
        });
    const operators = Array.from(set).sort((a, b) => a.localeCompare(b, "he"));
    operators.forEach(v => {
        const opt = document.createElement("option");
        opt.value = v;
        opt.textContent = v;
        operatorSelect.appendChild(opt);
    });
    if (activeOperator && operators.includes(activeOperator)) {
        operatorSelect.value = activeOperator;
    } else {
        activeOperator = "";
        operatorSelect.value = "";
    }
}
function getFilteredTimes() {
    return stationTimes.filter(r => {
        const weekOk = String(r[COL_WEEK] ?? "").trim() === activeWeek;
        if (!weekOk) return false;
        if (!activeOperator) return true;
        return String(r[COL_OPERATOR] ?? "").trim() === activeOperator;
    });
}

function refreshAllAfterFilterChange() {
    activeBusRowKey = null;

    rebuildStationTimes();
    populateWeekDropdown();
    populateOperatorDropdown();

    setActiveTrain(null);
    redrawTrains();
    redrawBuses();
    renderBusTable();
}
function navigateWithYearMonth() {
    if (!station || !Number.isFinite(activeYear) || !Number.isFinite(activeMonth)) return;

    const p = new URLSearchParams(window.location.search);
    p.set("station", station);
    p.set("year", String(activeYear));
    p.set("month", String(activeMonth));

    window.location.href = "/convergence/?" + p.toString();
}
// endregion COV 5H


// region COV 5I
dirSelect.addEventListener("change", () => {
    activeDirection = dirSelect.value;

    populateYearDropdown();
    populateMonthDropdown();
    updateTitleFromState();
    refreshAllAfterFilterChange();
});

yearSelect.addEventListener("change", () => {
    const ySel = parseInt(yearSelect.value, 10);
    activeYear = Number.isFinite(ySel) ? ySel : null;

    populateMonthDropdown();

    const mSel = parseInt(monthSelect.value, 10);
    activeMonth = Number.isFinite(mSel) ? mSel : null;

    navigateWithYearMonth();
});

monthSelect.addEventListener("change", () => {
    const mSel = parseInt(monthSelect.value, 10);
    activeMonth = Number.isFinite(mSel) ? mSel : null;

    navigateWithYearMonth();
});

weekSelect.addEventListener("change", () => {
    activeWeek = weekSelect.value;
    populateOperatorDropdown();

    activeBusRowKey = null;

    setActiveTrain(null);
    redrawTrains();
    redrawBuses();
    renderBusTable();
});

operatorSelect.addEventListener("change", () => {
    activeOperator = operatorSelect.value;

    activeBusRowKey = null;

    setActiveTrain(null);
    redrawTrains();
    redrawBuses();
    renderBusTable();
});
// endregion COV 5I


// region COV 5J
function redrawTrains() {
    svg.querySelectorAll(".train-item, .perc-item").forEach(el => el.remove());

    const filteredTimes = getFilteredTimes();
  const weekOnlyTimes = stationTimes.filter(r => String(r[COL_WEEK] ?? "").trim() === activeWeek);
    const seenTrainTime = new Set();
    const uniqueTrainRows = [];

    filteredTimes.forEach(row => {
        const timeVal = (activeDirection === "×œ×›×™×•×•×Ÿ ×ª×œ ××‘×™×‘")
            ? row["×–××Ÿ ×™×¦×™××ª ×”×¨×›×‘×ª ××”×ª×—× ×” (×¨×™×©×•×™)"]
            : row["×–××Ÿ ×”×’×¢×ª ×”×¨×›×‘×ª ×œ×ª×—× ×” (×¨×™×©×•×™)"];

        const y = timeToY(timeVal);
        if (y === null) return;

        const trainId = String(row["××¡×¤×¨ ×”×¨×›×‘×ª"] ?? "").trim();
        if (!trainId) return;

        const normalizedTime = extractHHMM(timeVal) || String(timeVal ?? "").trim();
        if (!normalizedTime) return;

        const uniqueKey = trainId + "||" + normalizedTime;
        if (seenTrainTime.has(uniqueKey)) return;
        seenTrainTime.add(uniqueKey);

        uniqueTrainRows.push({
            row,
            timeVal,
            y,
            trainId,
            trainUid: uniqueKey,
            xOffset: 0
        });
    });

    // Jitter only unique train-time items that are closer than 4 minutes.
    const pxPerMinute = (1920 - 40) / (24 * 60);
    const jitterThresholdPx = 4 * pxPerMinute;
    const jitterStepX = 10;

    uniqueTrainRows.sort((a, b) => a.y - b.y);

    let i = 0;
    while (i < uniqueTrainRows.length) {
        let j = i + 1;
        while (j < uniqueTrainRows.length && (uniqueTrainRows[j].y - uniqueTrainRows[j - 1].y) < jitterThresholdPx) {
            j += 1;
        }

        const clusterSize = j - i;
        const startX = -((clusterSize - 1) * jitterStepX) / 2;
        for (let k = 0; k < clusterSize; k += 1) {
            uniqueTrainRows[i + k].xOffset = startX + (k * jitterStepX);
        }
        i = j;
    }

    uniqueTrainRows.forEach(item => {
        const { row, timeVal, y, trainId, trainUid, xOffset } = item;

        if (activeDirection === "×œ×›×™×•×•×Ÿ ×ª×œ ××‘×™×‘") {
            const percKey = buildPercKeyForLookup(row, trainId);
            const percStr = percKey ? TRAIN_PERC[percKey] : null;

            if (percStr !== undefined && percStr !== null && String(percStr).trim() !== "") {
                const percText = document.createElementNS("http://www.w3.org/2000/svg", "text");

                percText.setAttribute("x", String(110 + xOffset));
                percText.setAttribute("y", String(y));
                percText.setAttribute("font-size", "12");
                percText.setAttribute("fill", "#333");
                percText.setAttribute("text-anchor", "end");
                percText.setAttribute("dominant-baseline", "middle");

                percText.setAttribute("direction", "ltr");
                percText.setAttribute("unicode-bidi", "plaintext");

                percText.textContent = String(percStr);

                const pTitle = document.createElementNS("http://www.w3.org/2000/svg", "title");
                pTitle.textContent = "××—×•×– ×”× ×¡×™×¢×•×ª ×”××¡×•× ×›×¨× ×•×ª";
                percText.appendChild(pTitle);

                percText.classList.add("perc-item");
                percText.setAttribute("data-train", trainId);
                percText.setAttribute("data-train-uid", trainUid);
                percText.style.display = "none";

                svg.appendChild(percText);
            }
        }

        const isGold = String(row["×¨×›×‘×ª ×–×”×‘"] ?? "").trim() === "×›×Ÿ";
        const color = isGold ? "gold" : "black";

        const tri = document.createElementNS("http://www.w3.org/2000/svg", "polygon");

        const x = 120 + xOffset;
        const size = 12;
        const yPos = y - size / 2;

        const p1 = x + "," + yPos;
        const p2 = (x - size / 2) + "," + (yPos + size);
        const p3 = (x + size / 2) + "," + (yPos + size);

        tri.setAttribute("points", p1 + " " + p2 + " " + p3);
        tri.setAttribute("fill", color);

        tri.classList.add("train-item");
        tri.setAttribute("data-train", trainId);
        tri.setAttribute("data-train-uid", trainUid);
        tri.style.cursor = "pointer";

        const trainTimeStr = extractHHMM(timeVal) || String(timeVal);
        const tTitle = document.createElementNS("http://www.w3.org/2000/svg", "title");
        tTitle.textContent = "×–××Ÿ: " + trainTimeStr + " | ×¨×›×‘×ª: " + trainId;
        tri.appendChild(tTitle);

        tri.addEventListener("click", (e) => {
            e.stopPropagation();
            if (activeTrainUid === trainUid) {
                setActiveTrain(null);
            } else {
                setActiveTrain(trainId, trainUid);
            }
        });

        svg.appendChild(tri);
    });

    setActiveTrain(activeTrain, activeTrainUid);
    updateBusHeadersSticky();
}
// endregion COV 5J

// region COV 5K
function clearBuses() {
  svg.querySelectorAll(".bus-item, .bus-header").forEach(el => el.remove());
}

// Build a unique key for one bus row (used to filter the table)
function buildBusRowKey(row) {
  const trainId = String(row["××¡×¤×¨ ×”×¨×›×‘×ª"] ?? "").trim();
  const shilot  = String(row["×©×™×œ×•×˜"] ?? "").trim();
  const makat = String(row['××§"×˜'] ?? "").trim();
  const t = extractHHMM(row["×–××Ÿ ×”×’×¢×” ×œ×ª×—× ×”"] ?? row["×–××Ÿ ×™×¦×™××” ××”×ª×—× ×”"] ?? "") || "";
  return trainId + "||" + shilot + "||" + makat + "||" + t;
}

function setActiveBusRow(rowOrNull) {
  activeBusRowKey = rowOrNull ? buildBusRowKey(rowOrNull) : null;
  renderBusTable();
}



// Collect bus rows that are â€œvalidâ€ for current view (must have time + signage)
function getBusRowsForCurrentView() {
  const busTimeCol = (activeDirection === "×œ×›×™×•×•×Ÿ ×ª×œ ××‘×™×‘") ? "×–××Ÿ ×”×’×¢×” ×œ×ª×—× ×”" : "×–××Ÿ ×™×¦×™××” ××”×ª×—× ×”";
  const filteredTimes = getFilteredTimes();
  const weekOnlyTimes = stationTimes.filter(r => String(r[COL_WEEK] ?? "").trim() === activeWeek);

  return filteredTimes.filter(r =>
    r[busTimeCol] && String(r["×©×™×œ×•×˜"] ?? "").trim() !== ""
  );
}

let busHeaderStickyBound = false;
function updateBusHeadersSticky() {
    const headers = svg.querySelectorAll(".bus-header");
    if (!headers.length) return;

    const svgRect = svg.getBoundingClientRect();
    const svgTopAbs = window.scrollY + svgRect.top;
    const baseY = 18;      // original header y in SVG
    const topPad = 8;      // distance from top while sticky
    const maxY = 1910;     // keep inside svg

    let desiredY = baseY;
    if (window.scrollY > svgTopAbs) {
      desiredY = baseY + (window.scrollY - svgTopAbs) + topPad;
    }

    desiredY = Math.min(desiredY, maxY);

    headers.forEach(h => {
        h.setAttribute("y", String(desiredY));

        const bg = h.previousElementSibling;
        if (bg && bg.classList.contains("bus-header-bg")) {
            const bb = h.getBBox();
            const padX = 6;
            const padY = 3;
            bg.setAttribute("x", String(bb.x - padX));
            bg.setAttribute("y", String(bb.y - padY));
            bg.setAttribute("width", String(bb.width + padX * 2));
            bg.setAttribute("height", String(bb.height + padY * 2));

            // Keep header layer above bus dots.
            svg.appendChild(bg);
            svg.appendChild(h);
        }
    });
}

function redrawBuses() {
  clearBuses();
  if (!busHeaderStickyBound) {
    window.addEventListener("scroll", updateBusHeadersSticky, { passive: true });
    window.addEventListener("resize", updateBusHeadersSticky);
    busHeaderStickyBound = true;
  }
  updateBusHeadersSticky();

  const busTimeCol = (activeDirection === "×œ×›×™×•×•×Ÿ ×ª×œ ××‘×™×‘") ? "×–××Ÿ ×”×’×¢×” ×œ×ª×—× ×”" : "×–××Ÿ ×™×¦×™××” ××”×ª×—× ×”";
  const filteredTimes = getFilteredTimes();
  const weekOnlyTimes = stationTimes.filter(r => String(r[COL_WEEK] ?? "").trim() === activeWeek);

  const busRows = filteredTimes.filter(r =>
    r[busTimeCol] && String(r["×©×™×œ×•×˜"] ?? "").trim() !== ""
  );

  // Build signage headers from week-level data so they stay visible even with operator filtering.
  const headerRows = weekOnlyTimes.filter(r =>
    r[busTimeCol] && String(r["\u05e9\u05d9\u05dc\u05d5\u05d8"] ?? "").trim() !== ""
  );
  const shilotValues = Array.from(new Set(headerRows.map(r => String(r["\u05e9\u05d9\u05dc\u05d5\u05d8"]).trim())));

  // Sort signage: numeric signage in numeric order, then strings alphabetically
  shilotValues.sort((a, b) => {
    const na = parseFloat(a);
    const nb = parseFloat(b);
    const aIsNum = !Number.isNaN(na);
    const bIsNum = !Number.isNaN(nb);
    if (aIsNum && bIsNum) return na - nb;
    return a.localeCompare(b);
  });

  // X layout math for columns
  const baseX = 170;
  const colW  = 34;
  const rightPad = 20;

  // Resize SVG width if there are many signage columns
  const minSvgWidth = 240;
  const neededWidth = baseX + shilotValues.length * colW + rightPad;
  svg.setAttribute("width", String(Math.max(minSvgWidth, neededWidth)));

  // Map signage value -> x coordinate
  const shilotToX = new Map();
  shilotValues.forEach((val, idx) => {
    shilotToX.set(val, baseX + idx * colW);
  });

  // Draw column headers at the top of SVG
  shilotValues.forEach(val => {
    const hx = shilotToX.get(val);

    const header = document.createElementNS("http://www.w3.org/2000/svg", "text");
    header.classList.add("bus-header");
    header.setAttribute("x", hx);
    header.setAttribute("y", "18");
    header.setAttribute("font-size", "12");
    header.setAttribute("fill", "#000");
    header.setAttribute("font-weight", "700");
    header.setAttribute("text-anchor", "middle");
    header.setAttribute("direction", "ltr");
    header.setAttribute("unicode-bidi", "plaintext");

    // White "pill" background around each header value
    const bg = document.createElementNS("http://www.w3.org/2000/svg", "rect");
    bg.classList.add("bus-header-bg");
    bg.setAttribute("rx", "4");
    bg.setAttribute("ry", "4");
    bg.setAttribute("fill", "#fff");
    bg.setAttribute("stroke", "#ddd");
    bg.setAttribute("stroke-width", "0.8");

    header.textContent = val;
    svg.appendChild(bg);
    svg.appendChild(header);

    // Must happen after header is in DOM so getBBox() is correct
    const bb = header.getBBox();
    const padX = 6;
    const padY = 3;
    bg.setAttribute("x", String(bb.x - padX));
    bg.setAttribute("y", String(bb.y - padY));
    bg.setAttribute("width", String(bb.width + padX * 2));
    bg.setAttribute("height", String(bb.height + padY * 2));
  });
  updateBusHeadersSticky();

  // For font scaling we need min/max passengers
  const passengerVals = busRows
    .map(r => parseFloat(r["×××•×¦×¢ × ×•×¡×¢×™× ×œ× ×¡×™×¢×”"]))
    .filter(v => !Number.isNaN(v));

  const pMin = passengerVals.length ? Math.min(...passengerVals) : 0.1;
  const pMax = passengerVals.length ? Math.max(...passengerVals) : 66;

  const minFont = 10;
  const maxFont = 26;

  function scaleFont(p) {
    let v = parseFloat(p);
    if (Number.isNaN(v)) v = pMin;

    const t = (pMax === pMin) ? 0.5 : (v - pMin) / (pMax - pMin);
    const curved = Math.sqrt(Math.max(0, Math.min(1, t)));
    return minFont + curved * (maxFont - minFont);
  }

  function getMakatValue(row) {
    const v1 = String(row["××§\"×˜"] ?? "").trim();
    if (v1) return v1;
    return String(row['××§"×˜'] ?? "").trim();
  }

  function getBusJitterGroupKey(row) {
    const makat = getMakatValue(row);
    const direction = String(row["×›×™×•×•×Ÿ"] ?? "").trim();
    const alternative = String(row["×—×œ×•×¤×”"] ?? "").trim();
    if (!makat || !direction || !alternative) return "";
    return makat + "||" + direction + "||" + alternative;
  }

  const busItems = [];
  busRows.forEach(row => {
    const busTimeVal = row[busTimeCol];
    const y = timeToY(busTimeVal);
    if (y === null) return;

    const shilot = String(row["×©×™×œ×•×˜"]).trim();
    const x = shilotToX.get(shilot);
    if (x === undefined) return;

    const trainId = String(row["××¡×¤×¨ ×”×¨×›×‘×ª"] ?? "").trim();
    if (!trainId) return;

    const avgPassengers = row["×××•×¦×¢ × ×•×¡×¢×™× ×œ× ×¡×™×¢×”"];
    const fontSize = (scaleFont(avgPassengers) * 3);

    busItems.push({
      row,
      x,
      y,
      trainId,
      groupKey: getBusJitterGroupKey(row),
      fontSize,
      makat: getMakatValue(row),
      timeStr: extractHHMM(busTimeVal) || String(busTimeVal),
      xOffset: 0
    });
  });

  // Jitter dots only when is identical and time gap is < 2 minutes.
  const pxPerMinute = (1920 - 40) / (24 * 60);
  const busJitterThresholdPx = 2 * pxPerMinute;
  const busJitterStepX = 8;
  const groupMap = new Map();

  busItems.forEach(item => {
    if (!item.groupKey) return;
    if (!groupMap.has(item.groupKey)) groupMap.set(item.groupKey, []);
    groupMap.get(item.groupKey).push(item);
  });

  groupMap.forEach(group => {
    group.sort((a, b) => a.y - b.y);

    let i = 0;
    while (i < group.length) {
      let j = i + 1;
      while (j < group.length && (group[j].y - group[j - 1].y) < busJitterThresholdPx) {
        j += 1;
      }

      const clusterSize = j - i;
      const startX = -((clusterSize - 1) * busJitterStepX) / 2;
      for (let k = 0; k < clusterSize; k += 1) {
        group[i + k].xOffset = startX + (k * busJitterStepX);
      }
      i = j;
    }
  });

  // Draw each bus as circle at (x=signage column, y=timeToY)
  busItems.forEach(item => {
    const { row, x, y, trainId, fontSize, makat, timeStr, xOffset } = item;

    const dot = document.createElementNS("http://www.w3.org/2000/svg", "circle");
    dot.setAttribute("cx", x + xOffset);
    dot.setAttribute("cy", y);
    dot.setAttribute("r", String(Math.max(0.5, fontSize * 0.05)));

    // green if on time, red if not
    const onTime = Number(row["×”×× ×”××•×˜×•×‘×•×¡ ××’×™×¢ ×‘×–××Ÿ"]);
    const busColor = (onTime === 1) ? "#118a2a" : "#7a0c0c";
    dot.setAttribute("fill", busColor);
    dot.style.cursor = "pointer";

    // Click => show only this row in the right-side table
    dot.addEventListener("click", (e) => {
      e.stopPropagation();
      setActiveBusRow(row);
    });

    dot.classList.add("bus-item");
    dot.setAttribute("data-train", trainId);

    // Tooltip for bus label
    const bTitle = document.createElementNS("http://www.w3.org/2000/svg", "title");
    bTitle.textContent =
      "×–××Ÿ: " + timeStr +
      " | ××§\"×˜: " + (makat || "ï¿½");

    dot.appendChild(bTitle);
    svg.appendChild(dot);
  });

  // Ensure bus visibility + perc visibility matches selected train state
  applyBusFilter();
  applyPercFilter();
}




// endregion COV 5K


// region COV 5L
function getTrainPercForRow(row) {
  const direct = row["××—×•×– ×”× ×¡×™×¢×•×ª ×©×¢××“×• ×‘×–×× ×™×"];
  if (direct !== null && direct !== undefined && String(direct).trim() !== "") {
    return String(direct).trim();
  }

  const trainId = String(row["××¡×¤×¨ ×”×¨×›×‘×ª"] ?? "").trim();
  const key = buildPercKeyForLookup(row, trainId);
  const v = key ? TRAIN_PERC[key] : null;
  return (v !== null && v !== undefined && String(v).trim() !== "") ? String(v).trim() : "â€”";
}

// Defines which fields appear in the table and in what order
const TABLE_FIELDS = [
  { key: "××¤×¢×™×œ", label: "××¤×¢×™×œ" },
  { key: '××§"×˜', label: '××§"×˜' },
  { key: "×›×™×•×•×Ÿ", label: "×›×™×•×•×Ÿ" },
  { key: "×—×œ×•×¤×”", label: "×—×œ×•×¤×”" },
  { key: "×–××Ÿ ×™×¦×™××”", label: "×–××Ÿ ×™×¦×™××”" },
  { key: "×××•×¦×¢ × ×•×¡×¢×™× ×œ× ×¡×™×¢×”", label: "×××•×¦×¢ × ×•×¡×¢×™× ×œ× ×¡×™×¢×”" },
  { key: "×–××Ÿ ×”×’×¢×” ×œ×ª×—× ×”", label: "×–××Ÿ ×”×’×¢×” ×œ×ª×—× ×”" },
  { key: "×˜×•×•×— ×–××Ÿ ×”×”×’×¢×” ×œ×ª×—× ×”", label: "×˜×•×•×— ×–××Ÿ ×”×”×’×¢×” ×œ×ª×—× ×”" },
  { key: "×”×¤×¨×© ×‘×“×§×•×ª (×××•×˜×•×‘×•×¡ ×œ×¨×›×‘×ª)", label: "×”×¤×¨×© ×‘×“×§×•×ª (×××•×˜×•×‘×•×¡ ×œ×¨×›×‘×ª)" },
  { key: "××¡×¤×¨ ×ª×¦×¤×™×•×ª", label: "××¡×¤×¨ ×ª×¦×¤×™×•×ª" },
  { key: "××¡×¤×¨ ×”× ×¡×™×¢×•×ª ×©×¢××“×• ×‘×–×× ×™×", label: "××¡×¤×¨ ×”× ×¡×™×¢×•×ª ×©×¢××“×• ×‘×–×× ×™×" },
  { key: "××—×•×– ×”× ×¡×™×¢×•×ª ×©×¢××“×• ×‘×–×× ×™×", label: "××—×•×– ×”× ×¡×™×¢×•×ª ×©×¢××“×• ×‘×–×× ×™×" },
  { key: "×”××œ×¦×” (×“×§×•×ª)", label: "×”××œ×¦×” ×‘×“×§×•×ª" }
];

const HEADER_FILTER_COLS = {
  operator: TABLE_FIELDS[0].key,
  makat: TABLE_FIELDS[1].key,
};

const activeHeaderFilters = {
  operator: "",
  makat: "",
};

let headerPopup = null;

function normText(v) {
  return String(v ?? "").trim().toLowerCase();
}

function getRowsAfterHeaderFilters(rows, excludeCol = null) {
  return rows.filter(r => {
    if (excludeCol !== "operator" && activeHeaderFilters.operator) {
      const opVal = String(r[HEADER_FILTER_COLS.operator] ?? "").trim();
      if (!normText(opVal).startsWith(normText(activeHeaderFilters.operator))) return false;
    }
    if (excludeCol !== "makat" && activeHeaderFilters.makat) {
      const makatVal = String(r[HEADER_FILTER_COLS.makat] ?? "").trim();
      if (!normText(makatVal).startsWith(normText(activeHeaderFilters.makat))) return false;
    }
    return true;
  });
}

function uniqueValuesFromRows(rows, key) {
  const vals = [];
  rows.forEach(r => {
    const v = String(r[key] ?? "").trim();
    if (v) vals.push(v);
  });
  return Array.from(new Set(vals)).sort((a, b) => a.localeCompare(b, "he"));
}

function ensureHeaderPopup() {
  if (headerPopup) return headerPopup;

  const popup = document.createElement("div");
  popup.className = "hdr-popup";
  popup.innerHTML = `
    <div class="popup-title">
      <span class="popup-title-label">×—×™×¤×•×©</span>
      <span class="popup-title-selected"></span>
    </div>
    <input type="text" placeholder="Type..." />
    <div class="popup-list"></div>
    <div class="popup-actions">
      <button class="btn btn-clear" type="button">× ×§×”</button>
      <button class="btn btn-close" type="button">×¡×’×•×¨</button>
    </div>
  `;
  document.body.appendChild(popup);
  headerPopup = popup;
  return popup;
}

function hideHeaderPopup() {
  if (headerPopup) headerPopup.style.display = "none";
}

function openHeaderPopup(anchorEl, filterCol, baseRows) {
  const popup = ensureHeaderPopup();
  const rect = anchorEl.getBoundingClientRect();
  popup.style.left = (rect.left + window.scrollX) + "px";
  popup.style.top = (rect.bottom + window.scrollY + 6) + "px";
  popup.style.display = "block";

  const rowsForOptions = getRowsAfterHeaderFilters(baseRows, filterCol);
  const key = HEADER_FILTER_COLS[filterCol];
  const allValues = uniqueValuesFromRows(rowsForOptions, key);

  const input = popup.querySelector("input");
  const list = popup.querySelector(".popup-list");
  const titleSelected = popup.querySelector(".popup-title-selected");
  const btnClear = popup.querySelector(".btn-clear");
  const btnClose = popup.querySelector(".btn-close");
  const currentSelected = String(activeHeaderFilters[filterCol] ?? "").trim();
  titleSelected.textContent = currentSelected ? `: ${currentSelected}` : "";

  function renderList(prefix) {
    const p = normText(prefix);
    const filtered = !p ? allValues : allValues.filter(v => normText(v).startsWith(p));
    list.innerHTML = "";

    filtered.slice(0, 200).forEach(v => {
      const item = document.createElement("div");
      item.className = "popup-item";
      item.textContent = v;
      item.addEventListener("click", () => {
        activeHeaderFilters[filterCol] = v;
        titleSelected.textContent = `: ${v}`;
        activeBusRowKey = null;
        hideHeaderPopup();
        renderBusTable();
      });
      list.appendChild(item);
    });

    if (!filtered.length) {
      const empty = document.createElement("div");
      empty.style.padding = "6px 8px";
      empty.style.color = "#666";
      empty.textContent = "No results";
      list.appendChild(empty);
    }
  }

  input.value = "";
  renderList("");
  input.oninput = () => renderList(input.value);

  btnClear.onclick = () => {
    activeHeaderFilters[filterCol] = "";
    titleSelected.textContent = "";
    activeBusRowKey = null;
    hideHeaderPopup();
    renderBusTable();
  };

  btnClose.onclick = () => hideHeaderPopup();

  setTimeout(() => input.focus(), 0);
}

document.addEventListener("click", (e) => {
  const popup = headerPopup;
  const isIcon = e.target.classList?.contains("th-search-btn");
  if (popup && popup.style.display === "block" && !popup.contains(e.target) && !isIcon) {
    hideHeaderPopup();
  }
});

let tableScrollSyncBound = false;

function updateTopTableScrollbar() {
  const top = document.getElementById("busTableTopScroll");
  const topInner = document.getElementById("busTableTopScrollInner");
  const main = document.getElementById("busTableMainScroll");
  const table = document.getElementById("busTable");
  if (!top || !topInner || !main || !table) return;

  const width = table.scrollWidth;
  topInner.style.width = width + "px";
  top.style.display = width > main.clientWidth ? "block" : "none";
}

function bindTableScrollSync() {
  if (tableScrollSyncBound) return;

  const top = document.getElementById("busTableTopScroll");
  const main = document.getElementById("busTableMainScroll");
  if (!top || !main) return;

  let syncingTop = false;
  let syncingMain = false;

  top.addEventListener("scroll", () => {
    if (syncingMain) return;
    syncingTop = true;
    main.scrollLeft = top.scrollLeft;
    syncingTop = false;
  });

  main.addEventListener("scroll", () => {
    if (syncingTop) return;
    syncingMain = true;
    top.scrollLeft = main.scrollLeft;
    syncingMain = false;
  });

  window.addEventListener("resize", updateTopTableScrollbar);
  tableScrollSyncBound = true;
}

function alignTableScrollToRight() {
  const top = document.getElementById("busTableTopScroll");
  const main = document.getElementById("busTableMainScroll");
  if (!top || !main) return;

  const maxLeft = Math.max(0, main.scrollWidth - main.clientWidth);
  main.scrollLeft = maxLeft;
  top.scrollLeft = maxLeft;
}

function renderBusTable() {
  const headerRow = document.getElementById("busTableHeaderRow");
  const body = document.getElementById("busTableBody");
  if (!headerRow || !body) return;

  // Build header
  headerRow.innerHTML = "";
  TABLE_FIELDS.forEach((f, idx) => {
    const th = document.createElement("th");
    if (idx === 0 || idx === 1) {
      const col = idx === 0 ? "operator" : "makat";
      th.innerHTML = `
        <div class="th-wrap">
          ${f.label}
          <span class="th-search-btn" data-col="${col}">ğŸ”</span>
        </div>
      `;
    } else {
      th.textContent = f.label;
    }
    headerRow.appendChild(th);
  });

  // Choose which rows to show
  const allRows = getBusRowsForCurrentView();
  const trainFilteredRows = activeTrain
    ? allRows.filter(r => buildBusRowKey(r).startsWith(String(activeTrain).trim() + "||"))
    : allRows;
  const headerFilteredRows = getRowsAfterHeaderFilters(trainFilteredRows);
  const rows = activeBusRowKey
    ? headerFilteredRows.filter(r => buildBusRowKey(r) === activeBusRowKey)
    : headerFilteredRows;

  // Build body
  body.innerHTML = "";

  rows.forEach(r => {
    const tr = document.createElement("tr");

    TABLE_FIELDS.forEach(f => {
      const td = document.createElement("td");

      let v = "";

      // NOTE:
      // You currently don't use "__perc__" in TABLE_FIELDS,
      // but the branch is here if you decide to add it later.
      if (f.key === "__perc__") {
        v = getTrainPercForRow(r);
      } else {
        v = r[f.key];
        if (v === null || v === undefined || String(v).trim() === "") {
          v = "â€”";
        } else {
          // If the label contains "×–××Ÿ", try to normalize to HH:MM
          if (String(f.label).includes("×–××Ÿ")) {
            v = extractHHMM(v) || String(v).trim();
          } else {
            v = String(v).trim();
          }
        }
      }

      td.textContent = v;
      tr.appendChild(td);
    });

    body.appendChild(tr);
  });

  const searchIcons = Array.from(headerRow.querySelectorAll(".th-search-btn"));
  searchIcons.forEach(icon => {
    icon.addEventListener("click", (e) => {
      e.stopPropagation();
      const col = icon.getAttribute("data-col");
      if (col !== "operator" && col !== "makat") return;
      openHeaderPopup(icon, col, trainFilteredRows);
    });
  });

  bindTableScrollSync();
  updateTopTableScrollbar();
  alignTableScrollToRight();
}
// Clicking "×”×¦×’ ×”×›×œ" resets table back to all rows
const clearBusBtn = document.getElementById("clearBusSelectionBtn");
if (clearBusBtn) {
  clearBusBtn.addEventListener("click", () => {
    activeBusRowKey = null;
    activeHeaderFilters.operator = "";
    activeHeaderFilters.makat = "";
    hideHeaderPopup();
    renderBusTable();
  });
}
// endregion COV 5L

// region COV 5M
populateYearDropdown();
populateMonthDropdown();
updateTitleFromState();

rebuildStationTimes();
populateWeekDropdown();
populateOperatorDropdown();

redrawTrains();
redrawBuses();
setActiveTrain(null);


renderBusTable();
// endregion COV 5M

</script>

</body>
</html>











